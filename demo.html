<!DOCTYPE html>
<html lang="pt-BR">
    <head>
        <title>Ferramenta de Carregamento Progressivo</title>
        <meta charset="utf-8" />
        <style>
            body { 
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
                line-height: 1.6;
                color: #333;
            }
            center {
                padding-bottom: 1em;
            }
            textarea {
                vertical-align: middle;
                font-family: monospace;
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 4px;
            }
            button {
                padding: 5px 15px;
                border-radius: 4px;
                border: 1px solid #888;
                cursor: pointer;
            }
            button:hover {
                background-color: #f0f0f0;
            }
            #controls {
                padding-bottom: 5px;
            }
            #options {
                margin-top: 10px;
                font-size: 0.9em;
            }
            #feedback {
                border: 1px solid #ccc;
                padding: 5px;
                margin-top: 5px;
                background-color: #f9f9f9;
                border-radius: 4px;
                max-width: 98%;
            }
            #metrics-summary {
                cursor: pointer;
                font-weight: bold;
                padding: 5px;
                display: list-item; 
                list-style: inside;
            }
            #metrics-summary:hover {
                background-color: #eee;
            }
            #metrics-display ul { 
                padding-left: 20px; 
                margin: 5px 0;
            }
            #metrics-display li { 
                margin-bottom: 5px; 
            }
        </style>
    </head>
    <body>
        <center>
            <h3>Ferramenta de Carregamento Progressivo</h3>
            Lucas Barcellos Oliveira - Candidato a M.Sc. em Engenharia de Sistemas e Computação - COPPE/UFRJ
        </center>

        <div id="controls">
            Mode: <textarea id="oper" rows="1" cols="8" placeholder="sample">sample</textarea>
            Attribute: <textarea id="attribute" rows="1" cols="5" placeholder="S1">S1</textarea>
            Aggregation: <textarea id="agg" rows="1" cols="5" placeholder="mean">mean</textarea>
            Precision (% or # of coefficients): <textarea id="precision" rows="1" cols="3" placeholder="100">100</textarea>
            Query: <textarea id="query" rows="1"cols="5" placeholder="N2&lt;40">N2&lt;40</textarea>
            <button id="submit">Submit</button>
            <div id="options">
                <input type="checkbox" id="chainRequestsCheckbox" checked>
                <label for="chainRequestsCheckbox">Garantir ordem progressiva (requisições sequenciais)</label>
            </div>
        </div>
        
        <div id="feedback">
            <p><strong>Status:</strong> <span id="status-indicator">Ocioso</span></p>
            <details>
                <summary id="metrics-summary">Métricas da Última Execução</summary>
                <div id="metrics-display" style="padding-top: 10px;">
                    <ul>
                        <li><strong>Time to First Plot (TTFP):</strong> <span id="ttfp">N/A</span></li>
                        <li><strong>Time to Last Plot (TTLP):</strong> <span id="ttfp-full">N/A</span></li>
                        <li><strong>Dados Transferidos:</strong>
                            <ul id="data-sizes">
                            </ul>
                        </li>
                    </ul>
                </div>
            </details>
        </div>
        
        <div id="vis"></div>

        <script type="module">
            import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
            import * as mathjs from 'https://cdn.jsdelivr.net/npm/mathjs@13.0.2/+esm';

            let startTime = 0;
            let firstPlotTimeCaptured = false;
            let finalPrecisionGoal = 0;
            
            const delay = ms => new Promise(res => setTimeout(res, ms));

            const width = 2000;
            const height = 700;
            const marginTop = 20;
            const marginRight = 20;
            const marginBottom = 40;
            const marginLeft = 50;
            
            const initialData = [{date:new Date(2012,0,1),close:0},{date:new Date(2012,11,31),close:160}];

            const locale = d3.timeFormatDefaultLocale({
                "dateTime": "%A, %e de %B de %Y. %X", "date": "%d/%m/%Y", "time": "%H:%M:%S", "periods": ["AM", "PM"], "days": ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"], "shortDays": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"], "months": ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], "shortMonths": ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
            });

            const x = d3.scaleUtc(d3.extent(initialData, d => d.date), [marginLeft, width - marginRight]);
            const y = d3.scaleLinear([0, d3.max(initialData, d => d.close)], [height - marginBottom, marginTop]);

            const svg = d3.create("svg")
                .attr("width", width).attr("height", height).attr("viewBox", [0, 0, width, height]).attr("style", "max-width: 100%; height: auto; height: intrinsic;");

            svg.append("g").attr("class", "x-axis").attr("transform", `translate(0,${height - marginBottom})`).style("font-size","32px").call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0).tickFormat(locale.format("%b")));
            svg.append("g").attr("class", "y-axis").attr("transform", `translate(${marginLeft},0)`).style("font-size","24px").call(d3.axisLeft(y).ticks(height / 80)).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").attr("x2", width - marginLeft - marginRight).attr("stroke-opacity", 0.1)).call(g => g.append("text").attr("x", -marginLeft).attr("y", 10).attr("fill", "currentColor").attr("text-anchor", "start"));
            
            function update(data, attribute) {
                const t = svg.transition().duration(1000);

                y.domain([0, d3.max(data, d => d[attribute]) || 0]).nice();
                svg.select(".y-axis").transition(t).call(d3.axisLeft(y).ticks(height / 80)).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").attr("stroke-opacity", 0.1).attr("x2", width - marginLeft - marginRight));

                svg.selectAll("circle")
                    .data(data, d => d.date)
                    .join(
                        enter => enter.append("circle").attr("r", 0).attr("cx", d => x(d.date)).attr("cy", d => y(d[attribute])),
                        update => update,
                        exit => exit.call(exit => exit.transition(t).attr("r", 0).remove())
                    )
                    .attr("fill", "tomato")
                    .transition(t)
                        .attr("cx", d => x(d.date))
                        .attr("cy", d => y(d[attribute]))
                        .attr("r", 3)
                    .transition()
                        .duration(500)
                        .attr("fill", "steelblue");
            }

            update(initialData,"close");
            vis.append(svg.node());

            const observer = new PerformanceObserver(list => {
                const dataSizesList = document.getElementById("data-sizes");
                for (const entry of list.getEntries()) {
                    if(entry.initiatorType === 'fetch' && entry.name.startsWith('http://127.0.0.1:8000')) { 
                        const urlParts = entry.name.split('/');
                        const precision = urlParts[urlParts.length - 2].split('?')[0];
                        const sizeKB = (entry.transferSize / 1024).toFixed(2);
                        const listItem = document.createElement("li");
                        listItem.textContent = `Precisão ${precision}: ${sizeKB} KB`;
                        dataSizesList.appendChild(listItem);
                    }
                }
            });
            observer.observe({type: "resource", buffered: true});

            function handleDataArrival(parsedData, attribute, precision) {
                 if (Array.isArray(parsedData) && parsedData.length > 0) {
                    const now = performance.now();
                    if (!firstPlotTimeCaptured) {
                        document.getElementById("ttfp").textContent = `${((now - startTime) / 1000).toFixed(2)} segundos`;
                        document.getElementById("status-indicator").textContent = `Refinando visualização...`;
                        firstPlotTimeCaptured = true;
                    }
                    if (parseInt(precision) === finalPrecisionGoal) {
                        document.getElementById("ttfp-full").textContent = `${((now - startTime) / 1000).toFixed(2)} segundos`;
                        document.getElementById("status-indicator").textContent = `Visualização completa.`;
                    }
                    update(parsedData, attribute);
                 } else {
                     console.warn("Dados recebidos vazios ou em formato inválido para precisão:", precision);
                 }
            }
            
            async function getData(oper, attribute, agg, precision, query){
                if (oper === "fft") {
                    return await getDataFFT(attribute, agg, precision, query);
                }
                const cacheBuster = `?v=${Date.now()}`;
                const url = `http://127.0.0.1:8000/${oper}/${attribute}/${agg}/${precision}/${query}${cacheBuster}`;
                
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
                    const json = await resp.json();
                    handleDataArrival(JSON.parse(json), attribute, precision);
                } catch (err) {
                    console.error(`Fetch error for precision ${precision}:`, err);
                }
            }

            async function getDataFFT(attribute, agg, coeffs, query){
                const cacheBuster = `?v=${Date.now()}`;
                const url = `http://127.0.0.1:8000/fft/${attribute}/${agg}/${coeffs}/${query}${cacheBuster}`;
                
                try {
                    const resp = await fetch(url);
                    if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
                    const list = await resp.json();
                    
                    let date = JSON.parse(list[0]);
                    let fftCoeffs = list[1];
                    for(let i = fftCoeffs.length; i < date.length; i++) fftCoeffs.push([0,0]);
                    let complexCoeffs = fftCoeffs.map(d => mathjs.complex({ "re": d[0], "im": d[1] }));
                    let inverse = mathjs.ifft(complexCoeffs);
                    const formattedData = date.map((d, i) => ({ date: d, [attribute]: inverse[i].re }));
                    handleDataArrival(formattedData, attribute, coeffs);
                } catch (err) {
                    console.error(`FFT Fetch error for ${coeffs} coeffs:`, err);
                }
            }

            async function startProgressiveLoad() {
                document.getElementById("status-indicator").textContent = "Iniciando requisições...";
                document.getElementById("ttfp").textContent = "N/A";
                document.getElementById("ttfp-full").textContent = "N/A";
                document.getElementById("data-sizes").innerHTML = "";
                
                startTime = performance.now();
                firstPlotTimeCaptured = false;
                
                const operVal = oper.value;
                const attrVal = attribute.value;
                const aggVal = agg.value;
                finalPrecisionGoal = parseInt(precision.value, 10);
                const queryVal = query.value.trim() === '' ? 'nofilter' : query.value;
                
                const precisionSteps = [1, 5, 10, 25, 50, 75];
                let precisionsToRequest = precisionSteps.filter(p => p < finalPrecisionGoal);
                precisionsToRequest.push(finalPrecisionGoal);
                precisionsToRequest = [...new Set(precisionsToRequest)].sort((a, b) => a - b);
                
                const chainRequests = document.getElementById("chainRequestsCheckbox").checked;

                if (chainRequests) {
                    document.getElementById("status-indicator").textContent = "Iniciando requisições sequenciais...";
                    for (const p of precisionsToRequest) {
                        document.getElementById("status-indicator").textContent = `Requisitando precisão ${p}...`;
                        await getData(operVal, attrVal, aggVal, p, queryVal);
                                                if (p !== finalPrecisionGoal) {
                           await delay(1500); 
                        }
                    }
                } else {
                    document.getElementById("status-indicator").textContent = "Iniciando requisições em paralelo...";
                    for (const p of precisionsToRequest) {
                        getData(operVal, attrVal, aggVal, p, queryVal);
                    }
                }
            }
            
            submit.onclick = startProgressiveLoad;
        </script>
    </body>
</html>